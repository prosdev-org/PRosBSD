#include <cpu/io.h>
#include <drivers/gpu/clgd64xx.h>
#include <stddef.h>
#include <stdint.h>

uint16_t vga_width = 320;
uint16_t vga_height = 200;
uint8_t vga_bpp = 8;
uint32_t vga_stride = 320;

static void write_reg_sequence(const uint16_t *data, const uint16_t port) {
    while (1) {
        const uint16_t val = *data++;
        if (val == 0xFFFF)
            break;
        outw(val, port);
    }
}

static uint16_t cirrus_crtc_port() {
    // 1 for color emulation, 0 for mono
    return (inb(0x3CC) & 1) ? 0x3D4 : 0x3B4;
}

// unlock registers
static void cirrus_unlock() {
    // Sequencer index 0x06 ‚Üê 0x12
    outw(0x1206, 0x3C4);
}

// set 64KB bank
static void cirrus_set_bank(const uint8_t bank) {
    outb(0x09, 0x3CE);
    outb((uint8_t) ((bank & 0x0F) | ((bank & 0x0F) << 4)), 0x3CF);
}

// write to banked VRAM
static void vram_write(uint32_t offset, const uint8_t *src, uint32_t len) {
    while (len) {
        const uint32_t bank = offset >> 16;
        const uint16_t off = (uint16_t) (offset & 0xFFFF);
        uint32_t chunk = 0x10000u - off;
        if (chunk > len)
            chunk = len;
        cirrus_set_bank((uint8_t) bank);
        for (uint32_t i = 0; i < chunk; i++) {
            VGA_FB_ADDR[off + i] = src[i];
        }
        offset += chunk;
        src += chunk;
        len -= chunk;
    }
}

// fill range in VRAM, bank-aware
static void vram_fill8(uint32_t offset, const uint8_t value, uint32_t len) {
    while (len) {
        const uint32_t bank = offset >> 16;
        const uint16_t off = (uint16_t) (offset & 0xFFFF);
        uint32_t chunk = 0x10000u - off;
        if (chunk > len)
            chunk = len;
        cirrus_set_bank((uint8_t) bank);
        for (uint32_t i = 0; i < chunk; i++) {
            VGA_FB_ADDR[off + i] = value;
        }
        offset += chunk;
        len -= chunk;
    }
}

static uint16_t cgraph_svgacolor[] = {0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x4005, 0x0506,
                                      0x0f07, 0xff08, 0x0009, 0x000a, 0x000b, 0xffff};

// 640x480x8
static uint16_t cseq_640x480x8[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1107, 0x580b, 0x580c, 0x580d,
                                    0x580e, 0x0412, 0x0013, 0x2017, 0x331b, 0x331c, 0x331d, 0x331e, 0xffff};
static uint16_t ccrtc_640x480x8[] = {0x2c11, 0x5f00, 0x4f01, 0x4f02, 0x8003, 0x5204, 0x1e05, 0x0b06,
                                     0x3e07, 0x4009, 0x000c, 0x000d, 0xea10, 0xdf12, 0x5013, 0x4014,
                                     0xdf15, 0x0b16, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};
// 640x480x16/15
static uint16_t cseq_640x480x16[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1707, 0x580b, 0x580c, 0x580d,
                                     0x580e, 0x0412, 0x0013, 0x2017, 0x331b, 0x331c, 0x331d, 0x331e, 0xffff};
static uint16_t ccrtc_640x480x16[] = {0x2c11, 0x5f00, 0x4f01, 0x4f02, 0x8003, 0x5204, 0x1e05, 0x0b06,
                                      0x3e07, 0x4009, 0x000c, 0x000d, 0xea10, 0xdf12, 0xa013, 0x4014,
                                      0xdf15, 0x0b16, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};
// 640x480x24
static uint16_t cseq_640x480x24[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1507, 0x580b, 0x580c, 0x580d,
                                     0x580e, 0x0412, 0x0013, 0x2017, 0x331b, 0x331c, 0x331d, 0x331e, 0xffff};
static uint16_t ccrtc_640x480x24[] = {0x2c11, 0x5f00, 0x4f01, 0x4f02, 0x8003, 0x5204, 0x1e05, 0x0b06,
                                      0x3e07, 0x4009, 0x000c, 0x000d, 0xea10, 0xdf12, 0xf013, 0x4014,
                                      0xdf15, 0x0b16, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};

// 800x600x8
static uint16_t cseq_800x600x8[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1107, 0x230b, 0x230c, 0x230d,
                                    0x230e, 0x0412, 0x0013, 0x2017, 0x141b, 0x141c, 0x141d, 0x141e, 0xffff};
static uint16_t ccrtc_800x600x8[] = {0x2311, 0x7d00, 0x6301, 0x6302, 0x8003, 0x6b04, 0x1a05, 0x9806,
                                     0xf007, 0x6009, 0x000c, 0x000d, 0x7d10, 0x5712, 0x6413, 0x4014,
                                     0x5715, 0x9816, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};
// 800x600x16/15
static uint16_t cseq_800x600x16[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1707, 0x230b, 0x230c, 0x230d,
                                     0x230e, 0x0412, 0x0013, 0x2017, 0x141b, 0x141c, 0x141d, 0x141e, 0xffff};
static uint16_t ccrtc_800x600x16[] = {0x2311, 0x7d00, 0x6301, 0x6302, 0x8003, 0x6b04, 0x1a05, 0x9806,
                                      0xf007, 0x6009, 0x000c, 0x000d, 0x7d10, 0x5712, 0xc813, 0x4014,
                                      0x5715, 0x9816, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};
// 800x600x24
static uint16_t cseq_800x600x24[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1507, 0x230b, 0x230c, 0x230d,
                                     0x230e, 0x0412, 0x0013, 0x2017, 0x141b, 0x141c, 0x141d, 0x141e, 0xffff};
static uint16_t ccrtc_800x600x24[] = {0x2311, 0x7d00, 0x6301, 0x6302, 0x8003, 0x6b04, 0x1a05, 0x9806,
                                      0xf007, 0x6009, 0x000c, 0x000d, 0x7d10, 0x5712, 0x2c13, 0x4014,
                                      0x5715, 0x9816, 0xc317, 0xff18, 0x001a, 0x321b, 0x001d, 0xffff};

// 1024x768x8
static uint16_t cseq_1024x768x8[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1107, 0x760b, 0x760c, 0x760d,
                                     0x760e, 0x0412, 0x0013, 0x2017, 0x341b, 0x341c, 0x341d, 0x341e, 0xffff};
static uint16_t ccrtc_1024x768x8[] = {0x2911, 0xa300, 0x7f01, 0x7f02, 0x8603, 0x8304, 0x9405, 0x2406,
                                      0xf507, 0x6009, 0x000c, 0x000d, 0x0310, 0xff12, 0x8013, 0x4014,
                                      0xff15, 0x2416, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};
// 1024x768x16/15
static uint16_t cseq_1024x768x16[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1707, 0x760b, 0x760c, 0x760d,
                                      0x760e, 0x0412, 0x0013, 0x2017, 0x341b, 0x341c, 0x341d, 0x341e, 0xffff};
static uint16_t ccrtc_1024x768x16[] = {0x2911, 0xa300, 0x7f01, 0x7f02, 0x8603, 0x8304, 0x9405, 0x2406,
                                       0xf507, 0x6009, 0x000c, 0x000d, 0x0310, 0xff12, 0x0013, 0x4014,
                                       0xff15, 0x2416, 0xc317, 0xff18, 0x001a, 0x321b, 0x001d, 0xffff};
// 1024x768x24
static uint16_t cseq_1024x768x24[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1507, 0x760b, 0x760c, 0x760d,
                                      0x760e, 0x0412, 0x0013, 0x2017, 0x341b, 0x341c, 0x341d, 0x341e, 0xffff};
static uint16_t ccrtc_1024x768x24[] = {0x2911, 0xa300, 0x7f01, 0x7f02, 0x8603, 0x8304, 0x9405, 0x2406,
                                       0xf507, 0x6009, 0x000c, 0x000d, 0x0310, 0xff12, 0x8013, 0x4014,
                                       0xff15, 0x2416, 0xc317, 0xff18, 0x001a, 0x321b, 0x001d, 0xffff};

// 1280x1024x8
static uint16_t cseq_1280x1024x8[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1107, 0x760b, 0x760c, 0x760d,
                                      0x760e, 0x0412, 0x0013, 0x2017, 0x341b, 0x341c, 0x341d, 0x341e, 0xffff};
static uint16_t ccrtc_1280x1024x8[] = {0x2911, 0xc300, 0x9f01, 0x9f02, 0x8603, 0x8304, 0x9405, 0x2406,
                                       0xf707, 0x6009, 0x000c, 0x000d, 0x0310, 0xff12, 0xa013, 0x4014,
                                       0xff15, 0x2416, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};
// 1280x1024x16/15
static uint16_t cseq_1280x1024x16[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1707, 0x760b, 0x760c, 0x760d,
                                       0x760e, 0x0412, 0x0013, 0x2017, 0x341b, 0x341c, 0x341d, 0x341e, 0xffff};
static uint16_t ccrtc_1280x1024x16[] = {0x2911, 0xc300, 0x9f01, 0x9f02, 0x8603, 0x8304, 0x9405, 0x2406,
                                        0xf707, 0x6009, 0x000c, 0x000d, 0x0310, 0xff12, 0x4013, 0x4014,
                                        0xff15, 0x2416, 0xc317, 0xff18, 0x001a, 0x321b, 0x001d, 0xffff};

// 1600x1200x8 (table only)
// static uint16_t cseq_1600x1200x8[] = {0x0300, 0x2101, 0x0f02, 0x0003, 0x0e04, 0x1107, 0x760b, 0x760c, 0x760d,
//                                       0x760e, 0x0412, 0x0013, 0x2017, 0x341b, 0x341c, 0x341d, 0x341e, 0xffff};
// static uint16_t ccrtc_1600x1200x8[] = {0x2911, 0xc300, 0x9f01, 0x9f02, 0x8603, 0x8304, 0x9405, 0x2406,
//                                        0xf707, 0x6009, 0x000c, 0x000d, 0x0310, 0xff12, 0xc813, 0x4014,
//                                        0xff15, 0x2416, 0xc317, 0xff18, 0x001a, 0x221b, 0x001d, 0xffff};

typedef struct {
    uint8_t code;
    uint16_t w, h;
    uint8_t bpp;
    uint8_t hidden_dac;
    const uint16_t *seq;
    const uint16_t *graph;
    const uint16_t *crtc;
} cirrus_mode_t;

static const cirrus_mode_t cirrus_modes[] = {
        {0x5F, 640, 480, 8, 0x00, cseq_640x480x8, cgraph_svgacolor, ccrtc_640x480x8},
        {0x64, 640, 480, 16, 0xE1, cseq_640x480x16, cgraph_svgacolor, ccrtc_640x480x16},
        {0x66, 640, 480, 15, 0xF0, cseq_640x480x16, cgraph_svgacolor, ccrtc_640x480x16},
        {0x71, 640, 480, 24, 0xE5, cseq_640x480x24, cgraph_svgacolor, ccrtc_640x480x24},

        {0x5C, 800, 600, 8, 0x00, cseq_800x600x8, cgraph_svgacolor, ccrtc_800x600x8},
        {0x65, 800, 600, 16, 0xE1, cseq_800x600x16, cgraph_svgacolor, ccrtc_800x600x16},
        {0x67, 800, 600, 15, 0xF0, cseq_800x600x16, cgraph_svgacolor, ccrtc_800x600x16},
        {0x78, 800, 600, 24, 0xE5, cseq_800x600x24, cgraph_svgacolor, ccrtc_800x600x24},

        {0x60, 1024, 768, 8, 0x00, cseq_1024x768x8, cgraph_svgacolor, ccrtc_1024x768x8},
        {0x74, 1024, 768, 16, 0xE1, cseq_1024x768x16, cgraph_svgacolor, ccrtc_1024x768x16},
        {0x68, 1024, 768, 15, 0xF0, cseq_1024x768x16, cgraph_svgacolor, ccrtc_1024x768x16},
        {0x79, 1024, 768, 24, 0xE5, cseq_1024x768x24, cgraph_svgacolor, ccrtc_1024x768x24},

        {0x6D, 1280, 1024, 8, 0x00, cseq_1280x1024x8, cgraph_svgacolor, ccrtc_1280x1024x8},
        {0x75, 1280, 1024, 16, 0xE1, cseq_1280x1024x16, cgraph_svgacolor, ccrtc_1280x1024x16},
        {0x69, 1280, 1024, 15, 0xF0, cseq_1280x1024x16, cgraph_svgacolor, ccrtc_1280x1024x16},
};

static const cirrus_mode_t *find_cirrus_mode(const uint8_t bios_code) {
    for (size_t i = 0; i < sizeof(cirrus_modes) / sizeof(cirrus_modes[0]); i++) {
        if (cirrus_modes[i].code == bios_code)
            return &cirrus_modes[i];
    }
    return NULL;
}

static void cirrus_set_mode_raw(const cirrus_mode_t *m) {
    cirrus_unlock();
    write_reg_sequence(m->seq, 0x3C4);
    write_reg_sequence(m->graph, 0x3CE);
    write_reg_sequence(m->crtc, cirrus_crtc_port());

    // program hidden DAC
    outb(0x00, 0x3C6);
    (void) inb(0x3C6);
    (void) inb(0x3C6);
    (void) inb(0x3C6);
    (void) inb(0x3C6);
    outb(m->hidden_dac, 0x3C6);
    outb(0xFF, 0x3C6);

    vga_width = m->w;
    vga_height = m->h;
    vga_bpp = m->bpp;
    vga_stride = (uint32_t) m->w * (m->bpp == 15 ? 2u : (m->bpp / 8u));
}

void vga_init(const vga_mode_t mode) {
    if (mode == CIRRUS_320x200x8) {
        outb(0x63, 0x3C2);

        outb(0x00, 0x3C4);
        outb(0x03, 0x3C5);
        outb(0x01, 0x3C4);
        outb(0x01, 0x3C5);
        outb(0x02, 0x3C4);
        outb(0x0F, 0x3C5);
        outb(0x03, 0x3C4);
        outb(0x00, 0x3C5);
        outb(0x04, 0x3C4);
        outb(0x0E, 0x3C5);

        // unlock CRTC
        outb(0x11, 0x3D4);
        outb(0x00, 0x3D5);
        const uint8_t crtc_regs[] = {0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x41, 0x00, 0x00, 0x00,
                                     0x00, 0x00, 0x00, 0x9C, 0x8E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3, 0xFF};
        for (uint8_t i = 0; i < 25; i++) {
            outb(i, 0x3D4);
            outb(crtc_regs[i], 0x3D5);
        }

        outb(0x00, 0x3CE);
        outb(0x00, 0x3CF);
        outb(0x01, 0x3CE);
        outb(0x00, 0x3CF);
        outb(0x02, 0x3CE);
        outb(0x00, 0x3CF);
        outb(0x03, 0x3CE);
        outb(0x00, 0x3CF);
        outb(0x04, 0x3CE);
        outb(0x00, 0x3CF);
        outb(0x05, 0x3CE);
        outb(0x40, 0x3CF);
        outb(0x06, 0x3CE);
        outb(0x05, 0x3CF);
        outb(0x07, 0x3CE);
        outb(0x0F, 0x3CF);
        outb(0x08, 0x3CE);
        outb(0xFF, 0x3CF);

        for (uint8_t i = 0; i < 0x10; i++) {
            (void) inb(0x3DA);
            outb(i, 0x3C0);
            outb(i, 0x3C0);
        }
        (void) inb(0x3DA);
        outb(0x20, 0x3C0);

        vga_width = 320;
        vga_height = 200;
        vga_bpp = 8;
        vga_stride = 320;
        return;
    }

    const cirrus_mode_t *m = find_cirrus_mode((uint8_t) mode);
    if (m) {
        cirrus_set_mode_raw(m);
    } else {
        const cirrus_mode_t *def = find_cirrus_mode(0x5F); // fallback: 640x480x8
        if (def)
            cirrus_set_mode_raw(def);
    }
}

void vga_draw_pixel(const uint16_t x, const uint16_t y, const uint32_t color) {
    if (x >= vga_width || y >= vga_height)
        return;
    uint32_t off;
    switch (vga_bpp) {
        case 8:
            off = (uint32_t) y * vga_stride + x;
            vram_fill8(off, (uint8_t) color, 1);
            break;

        case 15:
        case 16: {
            off = (uint32_t) y * vga_stride + (uint32_t) x * 2u;
            const uint8_t px[2] = {(uint8_t) (color & 0xFF), (uint8_t) ((color >> 8) & 0xFF)};
            vram_write(off, px, 2);
            break;
        }

        case 24: {
            off = (uint32_t) y * vga_stride + (uint32_t) x * 3u;
            const uint8_t px[3] = {(uint8_t) (color & 0xFF), (uint8_t) ((color >> 8) & 0xFF),
                                   (uint8_t) ((color >> 16) & 0xFF)};
            vram_write(off, px, 3);
            break;
        }

        default:
            break;
    }
}

void vga_clear(const uint32_t color) {
    const uint32_t fb_size = vga_stride * vga_height;
    if (vga_bpp == 8) {
        vram_fill8(0, (uint8_t) color, fb_size);
        return;
    }

    for (uint16_t y = 0; y < vga_height; y++) {
        const uint32_t off = (uint32_t) y * vga_stride;
        switch (vga_bpp) {
            case 15:
            case 16: {
                // supports up to 4096 pixels wide
                static uint8_t line[8192];
                const uint32_t need = (uint32_t) vga_width * 2u;
                for (uint32_t i = 0; i < need; i += 2) {
                    line[i + 0] = (uint8_t) (color & 0xFF);
                    line[i + 1] = (uint8_t) ((color >> 8) & 0xFF);
                }
                vram_write(off, line, need);
                break;
            }
            case 24: {
                // supports up to 5461 pixels wide
                static uint8_t line[16384];
                const uint32_t need = (uint32_t) vga_width * 3u;
                for (uint32_t i = 0, p = 0; i < vga_width; i++, p += 3) {
                    line[p + 0] = (uint8_t) (color & 0xFF);
                    line[p + 1] = (uint8_t) ((color >> 8) & 0xFF);
                    line[p + 2] = (uint8_t) ((color >> 16) & 0xFF);
                }
                vram_write(off, line, need);
                break;
            }
            default:
                break;
        }
    }
}
